
We are creating a Clojure application that will orchestrate a set of LLM models.
The models are accessible via HTTP through a single LiteLLM endpoint, which is already set up.
Some of the models are hosted in ollama.  Others are on OpenAI, Microsoft, or Gemini.
The models have no memory.  Whatever they need to know to act, must be supplied to them
on each request.

We are building a program that will conduct the design of a game,
and will then conduct one or more plays of that game.
This program is known as the director.
The LLM models it controls are known as agents.  These are what actually carry out
the design and plays of the game.  The director just sequences them and manages
communications among them.

This system is intended to design and play many different games, with different rules.
The game will be determined by the prompt given to the planner agent,
which for the moment we will assume has been pre-written.

The director operates by deciding which agent should act, sends that agent its instructions,
information about the game's currnet state, and collects the agent's response.
It repeats this sequence until the game ends, according to the rules.

There is an agent known as the planner, and a set of agents known as players.
The planner is a larger, relatively expensive model, capable of advanced reasoning.
The players can be less capable, less expensive models, as they will be playing the designed game
possibly several times, and each play may take several turns.

First the planner designs the rules of the game, according to its own prompt.
This is done once.

Then the players play the game, acting according to those rules.
Each player takes a turn, acting according to the rules.
The game will end at some point, as dictated by the rules.
That is, one of the turns will be the last one.
This set of turns is said to be a play of the game.

There may be more than one play of the same game.


* Data objects
  * planner prompt, which instructs the planner how to design the game
  * instructions, one for each player, which tells the player how to act on its turn
  * game state, initially produced by the planner, updated by each player on its turn

* The Planner

The planner designs the game that the players will play.
Its task here is one of mechanism design.
It designs rules for the players to follow.

The planner generates instructions for the players, that instruct them in how to carry out their role the scenario.
Some players might have the same instructions, but in general each player may have its own unique instructions.
Those instructions are stored, because each will be sent to its player on that player's turn.

* The player

On each of its turns, the director will send the player an instruction and a game state.
The instruction will tell it how to modify the game state, and the player will then
respond with the description of that new game state.

* The Director

The director's task is as follows.

During the planning phase:

The director is given a prompt for the planner.  This instructs the planner on how to design the game.
The director sends the prompt to the planner, and collects its response.
The planner's response will consist of a description of the initial state of the game,
and an instruction for each of the players.

During the play:

The current state of the game is either the initial state as produced by the planner,
if no turns have been taken yet (that is, this is the first turn), or it is the state
as returned by the most recent turn's player.

Based on the current state of the game, the director decides which player will
take a turn next, that is, which player's turn it is.

Construct a message consisting of that player's instructions, and the current state of the game.
Send that message to the player and collect its response.


We are given a function (core.call-model model-name prompt) which returns the response as a string.

For the first game, the players conduct a negotiation, following Roberts rules of order.


* Example

Here is is how a game might play out.  In this game, one player is the Chair, the others are A and B.
Here we use INSTRUCTION_A as a placeholder for the instruction for player A, and so on.

Director to Chair: 	INSTRUCTION_CHAIR
                                Item: Allot 100 coins among players.
Chair responds:     Meeting is now in order.  The Open agenda item is: Allot 100 coins among players.
                                Item: Allot 100 coins among players.

Director to A:          INSTRUCTION_A
                                Item: Allot 100 coins among players.

A responds:          I move I get 50 coins.

Director to B:          INSTRUCTION_B
                                Item: Allot 100 coins among players.
                                A: I move I get 50 coins.
B responds:          I move that I get 50 coins.

Director to Chair:     INSTRUCTION_CHAIR
                                Item: Allot 100 coins among players.
                                A: I move I get 50 coins.
                                B: I move I get 50 coins.
Chair:






* Wild ideas

   Use a PlantUML sequence diagram to specify an interaction, and compile that into a program.
