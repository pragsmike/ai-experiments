Okay, this is an interesting challenge: crafting a prompt for an AI coding assistant (like myself) to generate the *entire system* we've just built, based on its current, evolved state.

The prompt needs to be comprehensive, specifying the architecture, modules, key functions, data flows, and important behaviors (like JSON handling and persistence). It's like writing a detailed specification or a very thorough "meta-prompt."

Here's a attempt at such a prompt:

---

**Prompt for AI Coding Assistant (to generate the LLM Game Director System)**

"You are an expert Clojure developer tasked with creating a system called "LLM Game Director." This system orchestrates Large Language Models (LLMs) to both design and play turn-based games. The system will be command-line operated and interact with LLMs via a LiteLLM endpoint.

**I. Overall System Architecture & Core Concepts:**

1.  **Director Program:** A central Clojure application that manages the entire lifecycle.
2.  **LLM Agents:**
    *   **Planner Agent:** An LLM responsible for designing a game's rules, initial state, and player instructions based on a human-provided master prompt.
    *   **Player Agents:** LLMs that take on player roles and make moves within the designed game.
3.  **Stateless LLMs:** All LLM interactions are stateless; all necessary context must be provided in each API call.
4.  **LiteLLM Endpoint:** All communication with LLMs (Planner and Players) will go through a single LiteLLM `/chat/completions` endpoint (configurable, default `http://localhost:8000/chat/completions`).
5.  **Phases:**
    *   **Planning Phase:** The game is designed (or loaded from persistence).
    *   **Play Phase:** The designed game is played out turn by turn.
6.  **Persistence:** Game designs (initial state, player instructions, metadata) generated by the Planner are persisted to the filesystem and can be loaded for subsequent plays, avoiding repeated calls to the Planner.
7.  **Simulation Mode:** The system must support a simulation mode where LLM calls are replaced by pre-canned responses for development and testing.
8.  **Robust LLM Output Handling:** LLM responses are expected to be JSON (or sometimes EDN as a fallback), but may include preamble/postamble text or markdown (like triple backticks). The system must robustly extract and parse the core data block.

**II. Modular Structure (Clojure Namespaces):**

Create the following namespaces within a `director` root:

1.  **`director.core`:**
    *   Main application entry point (`-main`).
    *   Handles command-line argument parsing (using `clojure.tools.cli`) for:
        *   Planner prompt file path (`-p`, `--planner-prompt`).
        *   Simulation mode flag (`-s`, `--simulate`).
        *   Force re-planning flag (`-f`, `--force-plan`).
        *   Help flag (`-h`, `--help`).
    *   Orchestrates the planning and play phases by calling functions from `director.planning` and `director.play`.
    *   Manages a dynamic var `*call-model-fn*` to switch between real LLM calls (`director.llm-interface/real-call-model`) and simulated calls (`director.simulation/simulated-call-model`).
    *   Defines system-wide configurations: `game-designs-actual-base-dir` (e.g., "game_designs"), default planner prompt file, `planner-model-name-config`, `default-player-model-name-config`.

2.  **`director.util`:**
    *   `sanitize-filename [name-string]`: Creates filesystem-safe names.
    *   `parse-json-from-string-trusted [json-str error-context]`: Parses known-good JSON strings (e.g., from files written by the system) into Clojure maps with keywordized keys.
    *   `extract-data-block-from-llm [raw-llm-string]`: Robustly extracts the first top-level curly-brace-enclosed block (`{...}`) from a raw LLM string, skipping any preamble. It should handle potential backtick markdown (e.g., ` ```json {...} ``` ` or ` ```edn {...} ``` `) if it encloses the primary block.
    *   `parse-data-from-llm-response [raw-llm-string error-context]`: Uses `extract-data-block-from-llm`. Attempts to parse the extracted string first as JSON (keys keywordized). If JSON parsing fails, attempts to parse it as EDN (using `clojure.edn/read-string`). Returns parsed data or an error map (`{:error "..." :raw "..." :extracted "..."}`).

3.  **`director.persistence`:**
    *   Handles saving and loading game designs. All public functions should take `base-dir` (the root directory for all game designs, e.g., "game_designs") as their first argument.
    *   `get-game-design-dir-file [base-dir game-title-or-id]`: Returns a `java.io.File` object for a specific game's design subdirectory.
    *   `save-game-design-files! [game-design-dir-file planner-output-map planner-model-name-cfg]`: Saves `initial_state.json`, `[PlayerID].txt` for each player instruction, and `game_meta.json` (containing game title, ID, player list, and planner model name) into the `game-design-dir-file`.
    *   `load-game-design-from-files [game-design-dir-file]`: Loads a game design from the specified directory, reconstructing a map similar to `planner-output-map` and including `:loaded_from_file true` and `:game_design_dir`. Handles missing instruction files gracefully. Returns `nil` if core files (meta, initial state) are missing or unparseable.
    *   `load-planner-prompt-text [prompt-filepath]`: Loads text content from a file.
    *   `prompt-filepath->game-id [prompt-filepath]`: Derives a game ID from a prompt filename (e.g., "my_prompt.txt" -> "my_prompt").
    *   `prompt-filepath->design-dir-file [base-dir prompt-filepath]`: Composes previous helpers.
    *   `design-exists? [base-dir prompt-filepath]`: Checks if a design directory exists for a given prompt.
    *   `load-design-for-prompt [base-dir prompt-filepath]`: High-level load.
    *   `save-planner-output! [base-dir planner-output-map planner-model-name-cfg]`: High-level save. Derives game ID from `planner-output-map` to determine subdirectory.

4.  **`director.planning`:**
    *   `execute-planning-phase [base-dir planner-prompt-filepath force-plan? call-model-fn planner-model-name-cfg]`:
        *   Loads prompt text using `director.persistence`.
        *   If not `force-plan?` and `director.persistence/design-exists?` is true, attempts to `director.persistence/load-design-for-prompt`.
        *   If loading succeeds, returns the loaded design.
        *   Otherwise (forcing plan, design doesn't exist, or loading failed), calls the Planner LLM via `call-model-fn`.
        *   The Planner LLM is expected to return a single JSON string. This string is parsed using `director.util/parse-data-from-llm-response`.
        *   The parsed output (a map) must contain `:game_title`, `:initial_game_state` (map), and `:player_instructions` (map of PlayerID string to instruction string). Also add `:planner_model planner-model-name-cfg` to this map.
        *   If parsing or validation fails, return `nil`.
        *   If valid, save the design using `director.persistence/save-planner-output!`.
        *   Return the processed planner output map (including `:game_design_dir` and `:loaded_from_file false` if newly generated).

5.  **`director.play`:**
    *   `execute-play-phase [initial-game-state-map player-instructions-map call-model-fn player-model-name-cfg]`:
        *   Manages a turn-based game loop.
        *   In each turn:
            *   Gets `next_player_to_act` from the current game state. If nil/empty, game ends.
            *   Retrieves instructions for the current player.
            *   Constructs a prompt string (player instructions + current game state as JSON string).
            *   Calls the Player LLM via `call-model-fn` with `player-model-name-cfg` and the prompt.
            *   The Player LLM is expected to return a single JSON string, parsable by `director.util/parse-data-from-llm-response` into a map containing `{"utterance": "string", "new_game_state": {...map...}}`.
            *   Validate this response structure. If invalid, halt game and return current state.
            *   Print the `utterance` for narration.
            *   Update current game state to the received `new_game_state`.
        *   Loop continues until game ends. Return the final game state.

6.  **`director.llm_interface`:**
    *   `LITELLM_ENDPOINT` (def, e.g., "http://localhost:8000/chat/completions").
    *   `real-call-model [model-name prompt-string _ignored-cfg]`: Takes model name and prompt. Makes an HTTP POST request to `LITELLM_ENDPOINT` using `clj-http.client`. The request body should be JSON: `{"model": "model-name", "messages": [{"role": "user", "content": "prompt-string"}]}`. Parses the JSON response from LiteLLM to extract `[:choices 0 :message :content]` which is the LLM's raw string output. Handles HTTP errors and parsing errors, returning an error JSON string like `{"error": "..."}` on failure.

7.  **`director.simulation`:**
    *   `simulated-call-model [model-name prompt-string]`:
        *   If `model-name` matches the configured planner model name (e.g., "openai/gpt-3.5-turbo" or your `planner-model-name-config`), return a hardcoded, valid JSON string representing a complete planner output (game title, initial state, player instructions for a sample game like Robert's Rules).
        *   Otherwise (for player models), use an atom-backed queue (`game-turn-responses`) of pre-defined JSON response strings (each `{"utterance": "...", "new_game_state": {...}}`). Dequeue and return one response per call. If the queue is empty, return a default "out of script" error response.
    *   `initialize-simulated-game! []`: Resets and populates the `game-turn-responses` queue with a sequence of responses for the sample game.

**III. Key Data Formats (Strict JSON where specified):**

*   **Planner Output / Persisted Design:** As detailed in `director.persistence` (game_meta.json, initial_state.json, [PlayerID].txt). `initial_game_state` must be valid JSON with string keys.
*   **Player LLM Input:** String (instructions + JSON string of game state).
*   **Player LLM Output:** JSON string `{"utterance": "...", "new_game_state": {...}}`. ALL keys in this structure MUST be double-quoted strings. `new_game_state` itself must be a valid JSON object representing the complete new state.
*   **Internal Game State:** Clojure maps, keywordized when parsed from trusted JSON or EDN.

**IV. Dependencies:**
*   `org.clojure/clojure` (e.g., 1.11.1)
*   `org.clojure/data.json`
*   `clj-http/clj-http` (for `llm_interface`)
*   `org.clojure/tools.cli`
*   (For testing: `io.github.cognitect-labs/test-runner`)

**V. Example Scenario (Robert's Rules):**
The system should be capable of running a game like Robert's Rules of Order for coin allotment, as previously discussed and simulated. The planner prompt should guide the Planner LLM to create instructions for Player LLMs (e.g., Mistral 7B) that emphasize the strict JSON output format with double-quoted string keys.

Generate the Clojure code for these namespaces. Ensure functions are well-documented regarding their purpose, arguments, and return values. Prioritize clarity and adherence to the specified modular structure."
---

This prompt is quite dense, but it attempts to cover all the critical aspects of the system you've built. It specifies:
*   The overall goal and main components.
*   The exact namespace structure and the primary responsibilities/functions of each.
*   Data flow between components.
*   Strict requirements for JSON where LLMs produce it.
*   The persistence mechanism.
*   The simulation mechanism.
*   The CLI interface.

An advanced AI coding assistant given this prompt should be able to generate a codebase very similar to what we've developed. It highlights the iterative nature of software design â€“ the current system is far more detailed and robust than the initial concept.
